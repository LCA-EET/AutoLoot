OUTER_SET xa_matchCountA = 0
OUTER_SET xa_matchCountB = 0

PRINT ~Patching UI.MENU.~
	
COPY_EXISTING ~UI.MENU~ ~override/UI.MENU~

REPLACE_TEXTUALLY ~actionAlt "showGroundItemDescription\([0-9]\)"~ ~~

REPLACE_TEXTUALLY ~Infinity_PushMenu( 'OPTIONS_AUTOPAUSE' );~
%
		Infinity_PushMenu( 'OPTIONS_AUTOPAUSE' );
		"
	}
	button
	{
		area		104 596 48 48
		bam			XAALBTN
		sequence	2
		text 		""
		text style	"button"
		action
		"
			selectedOpt = 0
			Infinity_PushMenu( 'BUBB_AUTOLOOT_OPTIONS' );
%
	
REPLACE_TEXTUALLY ~function displayTHAC()~ 
%
	xa_alreplace0function displayTHAC()
%

REPLACE_TEXTUALLY ~xa_alreplace0~ 
~
	-- BUBB EDIT DEBUG DUMP START

	function alphanumericSortEntries(o)
	   local function conv(s)
		  local res, dot = "", ""
		  for n, m, c in tostring(s):gmatch"(0*(%d*))(.?)" do
			 if n == "" then
				dot, c = "", dot..c
			 else
				res = res..(dot == "" and ("%03d%s"):format(#m, m)
									  or "."..n)
				dot, c = c:match"(%.?)(.*)"
			 end
			 res = res..c:gsub(".", "\0%0")
		  end
		  return res
	   end
	   table.sort(o,
		  function (a, b)
			 local ca, cb = conv(a.string), conv(b.string)
			 return ca < cb or ca == cb and a.string < b.string
		  end)
	   return o
	end
	xa_alreplace1
~	
REPLACE_TEXTUALLY ~xa_alreplace1~ 
%
	function fillDumpLevel(tableName, levelTable, levelToFill, levelTableKey)

		local tableKey, tableValue = next(levelTable, levelTableKey)
		while tableValue ~= nil do

			local tableValueType = type(tableValue)

			if tableValueType == 'string' or tableValueType == 'number' or tableValueType == 'boolean' then

				local entry = {}
				entry.string = tableValueType..' '..tableKey..' = '
				entry.value = tableValue
				table.insert(levelToFill, entry)

			elseif tableValueType == 'table' then

				if tableKey ~= '_G' then

					local entry = {}
					entry.string = tableValueType..' '..tableKey..':\n'
					entry.value = {} --entry.value is a levelToFill

					entry.value.previous = {}
					entry.value.previous.tableName = tableName
					entry.value.previous.levelTable = levelTable
					entry.value.previous.levelToFill = levelToFill
					entry.value.previous.levelTableKey = tableKey

					table.insert(levelToFill, entry)

					return fillDumpLevel(tableKey, tableValue, entry.value)
				end
			elseif tableValueType == 'userdata' then

				metatable = getmetatable(tableValue)
				local entry = {}

				if metatable ~= nil then

					entry.string = tableValueType..' '..tableKey..':\n'
					entry.value = {} --entry.value is a levelToFill

					entry.value.previous = {}
					entry.value.previous.tableName = tableName
					entry.value.previous.levelTable = levelTable
					entry.value.previous.levelToFill = levelToFill
					entry.value.previous.levelTableKey = tableKey

					table.insert(levelToFill, entry)

					return fillDumpLevel(tableKey, metatable, entry.value)
				else

					entry.string = tableValueType..' '..tableKey..' = '
					entry.value = 'nil'
					table.insert(levelToFill, entry)
				end
			else

				local entry = {}
				entry.string = tableValueType..' '..tableKey
				entry.value = nil
				table.insert(levelToFill, entry)
			end

			--Iteration
			tableKey, tableValue = next(levelTable, tableKey)
			--Iteration
		end

		--Sort the now finished level
		alphanumericSortEntries(levelToFill)
		--Sort the now finished level

		local previous = levelToFill.previous

		if previous ~= nil then

			--Clear out "previous" metadata, as it is no longer needed.
			local previousTableName = previous.tableName
			local previousLevelTable = previous.levelTable
			local previousLevelToFill = previous.levelToFill
			local previousLevelTableKey = previous.levelTableKey
			levelToFill.previous = nil
			--Clear out "previous" metadata, as it is no longer needed.

			return fillDumpLevel(previousTableName, previousLevelTable,
								 previousLevelToFill, previousLevelTableKey)
		else
			return levelToFill
		end
	end
	function printEntries(entriesTable, indentLevel, indentStrings, previousState, levelTableKey)

		tableEntryKey, tableEntry = next(entriesTable, levelTableKey)
		while(tableEntry ~= nil) do

			tableEntryString = tableEntry.string
			tableEntryValue = tableEntry.value
			indentString = indentStrings[indentLevel]

			if tableEntryValue ~= nil then

				if type(tableEntryValue) ~= 'table' then

					valueToPrint = string.gsub(tostring(tableEntryValue), '\n', '\\n')
					print(indentString..tableEntryString..valueToPrint)
				else
		
					print(indentString..tableEntryString)
					print(indentString..'{')

					local previous = {}
					previous.entriesTable = entriesTable
					previous.indentLevel = indentLevel
					previous.levelTableKey = tableEntryKey
					previous.previousState = previousState

					indentLevel = indentLevel + 1

					indentStringsSize = #indentStrings
					if indentLevel > indentStringsSize then
						indentStrings[indentStringsSize + 1] = indentStrings[indentStringsSize]..'\t'
					end

					return printEntries(tableEntryValue, indentLevel, indentStrings, previous)
				end
			else
				print(indentString..tableEntryString)
			end

			--Increment
			tableEntryKey, tableEntry = next(entriesTable, tableEntryKey)
			--Increment
		end

		print(indentStrings[indentLevel - 1]..'}')

		--Finish previous levels
		if previousState ~= nil then

			return printEntries(previousState.entriesTable, previousState.indentLevel, indentStrings,
								previousState.previousState, previousState.levelTableKey)
		end
	end

	function dump(key, valueToDump)

		valueToDumpType = type(valueToDump)

		if valueToDumpType == 'string' or valueToDumpType == 'number' or valueToDumpType == 'boolean' then

			print(valueToDumpType..' '..key..' = '..valueToDump)

		elseif valueToDumpType == 'table' then

			print(valueToDumpType..' '..key..':')
			print('{')
			entries = fillDumpLevel(key, valueToDump, {})
			printEntries(entries, 1, {[0] = '', [1] = '\t'})

		elseif valueToDumpType == 'userdata' then

			metatable = getmetatable(valueToDump)

			if metatable ~= nil then

				print(valueToDumpType..' '..key..':')
				print('{')
				entries = fillDumpLevel(key, metatable, {})
				printEntries(entries, 1, {[0] = '', [1] = '\t'})
			else

				print(valueToDumpType..' '..key..' = nil')
			end
		else

			print(valueToDumpType..' '..key)
		end
	end
	
	-- BUBB EDIT DEBUG DUMP END
	
	xa_alreplace2
%	

REPLACE_TEXTUALLY ~xa_alreplace2~ 
%
	-- XA functions
	
	function xa_spaceRemaining()
		characters = {}
		Infinity_UpdateLuaStats()
		local emptySpaces = 0
		for key, character in pairs(characters) do
			local equipment = character.equipment
			for i = 0, 15, 1 do
				local groupKey = "group"..i
				local isEmpty = equipment[groupKey].empty
				if isEmpty == 1 then
					emptySpaces = emptySpaces + 1
				end
			end
		end
		return emptySpaces
	end

	-- BUBB EDIT LOOT START
	function doesCharacterHaveSpace()
		characters = {}
		Infinity_UpdateLuaStats()
		for key, character in pairs(characters) do
			local equipment = character.equipment
			for i = 0, 15, 1 do
				local groupKey = "group"..i
				local isEmpty = equipment[groupKey].empty
				if isEmpty == 1 then
					return true
				end
			end
		end
		return false
	end
	function getPricePerWeight(price, weight)
		if price == 0 then
			return 0
		elseif weight == 0 then
			return price
		else
			return price / weight
		end
	end

	function decideWhetherToPickUp(itemRes, itemInfo)

		-- Critical Items
		if bubbALOptCriticalItemsToggle == 1 then
			if itemInfo.critical == 1 then
				return true
			end
		end

		-- Enchanted Weapons
		if bubbALOptEnchantedWeaponsToggle == 1 then
			if itemInfo.enchantment >= tonumber(bubbALOptEnchantedWeaponsField) then
				return true
			end
		end

		-- Price
		if bubbALOptPriceToggle == 1 then
			if itemInfo.price >= tonumber(bubbALOptPriceField) then
				return true
			end
		end

		-- Price per Weight
		if bubbALOptPricePerWeightToggle == 1 then
			if getPricePerWeight(itemInfo.price, itemInfo.weight) >= tonumber(bubbALOptPricePerWeightField) then
				return true
			end
		end

		return false
	end

	function pickupLoot()
		if (xa_iterations < 10) then
			xa_iterations = xa_iterations + 1
			return
		end
		xa_iterations = 0
		if bubbALOptOnToggle == 1 then
			-- Stupid check because LUA starts tables at index 1
			local spaceRemaining = 0
			if loot.groundItems[0] == nil then
				return
			end
			
			local groundItemCount = #loot.groundItems
			
			if (groundItemCount == 0) then
				return
			end
			
			if (xa_itemCheckNeeded == true) then
				spaceRemaining = xa_spaceRemaining()
				-- Infinity_DisplayString("[Auto Loot] Space Remaining:"..spaceRemaining)
			end
			
			for i = 0, groundItemCount, 1 do
				local groundItemSlot = loot.groundItems[i]
				local groundItem = groundItemSlot.item
				local info = lootInfo[groundItem.res]
				
				-- Gold doesn't need an empty space check
				if groundItem.res == "MISC07" then 
					if (bubbALOptGoldToggle == 1) then
						Infinity_DisplayString("[Auto Loot] Picking up gold.")
						worldScreen:OnGroundButtonClick(groundItemSlot.slotId, groundItemSlot.containerId, groundItem.res)
					end
				elseif (xa_itemCheckNeeded == true) and (spaceRemaining > 0) then
					if decideWhetherToPickUp(groundItem.res, info) then
						Infinity_DisplayString("[Auto Loot] Picking up "..groundItem.name)
						worldScreen:OnGroundButtonClick(groundItemSlot.slotId, groundItemSlot.containerId, groundItem.res)
						spaceRemaining = (spaceRemaining - 1)
					end
				end
			end
		end
	end
	function xa_validateEntry(toggle, field)
		if(toggle == 1) then
			if(field == "") then
				return 0
			end
		end
		return toggle
	end
	function writeAutolootOptions()
		-- Infinity_DisplayString("[Auto Loot] On Close Called.") 
		
		bubbALOptPriceToggle = xa_validateEntry(bubbALOptPriceToggle, bubbALOptPriceField)
		bubbALOptEnchantedWeaponsToggle = xa_validateEntry(bubbALOptEnchantedWeaponsToggle, bubbALOptEnchantedWeaponsField)
		bubbALOptPricePerWeightToggle = xa_validateEntry(bubbALOptPricePerWeightToggle, bubbALOptPricePerWeightField)
	
		if ((bubbALOptCriticalItemsToggle == 1) or
			(bubbALOptEnchantedWeaponsToggle == 1) or
			(bubbALOptPriceToggle == 1) or
			(bubbALOptPricePerWeightToggle == 1))
		then
			-- Infinity_DisplayString("[Auto Loot] IC Needed = true.") 
			xa_itemCheckNeeded = true
		else
			-- Infinity_DisplayString("[Auto Loot] IC Needed = false.") 
			xa_itemCheckNeeded = false
		end
		
		Infinity_SetINIValue('Bubb Autoloot', 'bubbALOptOnToggle',               tostring(bubbALOptOnToggle))
		Infinity_SetINIValue('Bubb Autoloot', 'bubbALOptCriticalItemsToggle',    tostring(bubbALOptCriticalItemsToggle))
		Infinity_SetINIValue('Bubb Autoloot', 'bubbALOptEnchantedWeaponsToggle', tostring(bubbALOptEnchantedWeaponsToggle))
		Infinity_SetINIValue('Bubb Autoloot', 'bubbALOptEnchantedWeaponsField',  bubbALOptEnchantedWeaponsField)
		Infinity_SetINIValue('Bubb Autoloot', 'bubbALOptGoldToggle',             tostring(bubbALOptGoldToggle))
		Infinity_SetINIValue('Bubb Autoloot', 'bubbALOptPriceToggle',            tostring(bubbALOptPriceToggle))
		Infinity_SetINIValue('Bubb Autoloot', 'bubbALOptPriceField',             bubbALOptPriceField)
		Infinity_SetINIValue('Bubb Autoloot', 'bubbALOptPricePerWeightToggle',   tostring(bubbALOptPricePerWeightToggle))
		Infinity_SetINIValue('Bubb Autoloot', 'bubbALOptPricePerWeightField',    bubbALOptPricePerWeightField)
	end
	
	function initializeAutolootOptionsMenu(itemName)
		-- Infinity_DisplayString("[Auto Loot] On Open Called.") 
		local screenWidth, screenHeight = Infinity_GetScreenSize()
		local backgroundX, backgroundY, backgroundWidth, backgroundHeight = Infinity_GetArea('bubbALOptBackground')
		local horizontalMargin = screenWidth - backgroundWidth
		local newBackGroundX = horizontalMargin / 2
		local verticalMargin = screenHeight - backgroundHeight
		local newBackGroundY = verticalMargin / 2

		-- Background
		Infinity_SetArea('bubbALOptBackground', newBackGroundX, newBackGroundY, nil, nil)

		-- Exit Button
		Infinity_SetArea('bubbALOptExitButton', newBackGroundX + backgroundWidth - 54, newBackGroundY + 10, nil, nil)

		-- Autoloot On
		Infinity_SetArea('bubbALOptOnToggle', newBackGroundX + 10, newBackGroundY + 10 + (32 + 10) * 0, nil, nil)
		Infinity_SetArea('bubbALOptOn',       newBackGroundX + 52, newBackGroundY + 10 + (32 + 10) * 0, nil, nil)

		-- Critical Items
		Infinity_SetArea('bubbALOptCriticalItemsToggle', newBackGroundX + 10, newBackGroundY + 10 + (32 + 10) * 1, nil, nil)
		Infinity_SetArea('bubbALOptCriticalItems',       newBackGroundX + 52, newBackGroundY + 10 + (32 + 10) * 1, nil, nil)

		-- Enchanted Weapons
		Infinity_SetArea('bubbALOptEnchantedWeaponsToggle', newBackGroundX + 10,           newBackGroundY + 10 + (32 + 10) * 2, nil, nil)
		Infinity_SetArea('bubbALOptEnchantedWeapons',       newBackGroundX + 52,           newBackGroundY + 10 + (32 + 10) * 2, nil, nil)
		Infinity_SetArea('bubbALOptEnchantedWeaponsField',  newBackGroundX + 52 + 356 + 5, newBackGroundY + 10 + (32 + 10) * 2, nil, nil)

		-- Gold
		Infinity_SetArea('bubbALOptGoldToggle', newBackGroundX + 10, newBackGroundY + 10 + (32 + 10) * 3, nil, nil)
		Infinity_SetArea('bubbALOptGold',       newBackGroundX + 52, newBackGroundY + 10 + (32 + 10) * 3, nil, nil)

		-- Price
		Infinity_SetArea('bubbALOptPriceToggle', newBackGroundX + 10,           newBackGroundY + 10 + (32 + 10) * 4, nil, nil)
		Infinity_SetArea('bubbALOptPrice',       newBackGroundX + 52,           newBackGroundY + 10 + (32 + 10) * 4, nil, nil)
		Infinity_SetArea('bubbALOptPriceField',  newBackGroundX + 52 + 218 + 5, newBackGroundY + 10 + (32 + 10) * 4, nil, nil)

		-- Price per Weight
		Infinity_SetArea('bubbALOptPricePerWeightToggle', newBackGroundX + 10,           newBackGroundY + 10 + (32 + 10) * 5, nil, nil)
		Infinity_SetArea('bubbALOptPricePerWeight',       newBackGroundX + 52,           newBackGroundY + 10 + (32 + 10) * 5, nil, nil)
		Infinity_SetArea('bubbALOptPricePerWeightField',  newBackGroundX + 52 + 308 + 5, newBackGroundY + 10 + (32 + 10) * 5, nil, nil)

	end

	bubbALOptOnToggle =               Infinity_GetINIValue('Bubb Autoloot', 'bubbALOptOnToggle',               0)
	bubbALOptCriticalItemsToggle =    Infinity_GetINIValue('Bubb Autoloot', 'bubbALOptCriticalItemsToggle',    0)
	bubbALOptEnchantedWeaponsToggle = Infinity_GetINIValue('Bubb Autoloot', 'bubbALOptEnchantedWeaponsToggle', 0)
	bubbALOptEnchantedWeaponsField =  Infinity_GetINIValue('Bubb Autoloot', 'bubbALOptEnchantedWeaponsField',  '1')
	bubbALOptGoldToggle =             Infinity_GetINIValue('Bubb Autoloot', 'bubbALOptGoldToggle',             0)
	bubbALOptPriceToggle =            Infinity_GetINIValue('Bubb Autoloot', 'bubbALOptPriceToggle',            0)
	bubbALOptPriceField =             Infinity_GetINIValue('Bubb Autoloot', 'bubbALOptPriceField',             '1')
	bubbALOptPricePerWeightToggle =   Infinity_GetINIValue('Bubb Autoloot', 'bubbALOptPricePerWeightToggle',   0)
	bubbALOptPricePerWeightField =    Infinity_GetINIValue('Bubb Autoloot', 'bubbALOptPricePerWeightField',    '1')

	bubbALOptPausedOnOpen = false
	-- BUBB EDIT LOOT END
	xa_iterations = 0;
%

APPEND ~UI.MENU~ 
%
	-- BUBB EDIT LOOT START
	menu
	{
		name "BUBB_AUTOLOOT_OPTIONS"
		modal
		onOpen 
		"
			initializeAutolootOptionsMenu()
		"
		onClose 
		"
			writeAutolootOptions()
		"

		-- Background
		label
		{
			name "bubbALOptBackground"
			area -1 -1 500 265
			rectangle 0
		}

		-- Exit Button
		button
		{
			name "bubbALOptExitButton"
			bam GUIOSW
			area -1 -1 44 44
			sequence 2
			action 
			"
				Infinity_PopMenu('BUBB_AUTOLOOT_OPTIONS')	
			"
		}

		-- Autoloot On
		button
		{
			name "bubbALOptOnToggle"
			area -1 -1 32 32
			bam ROUNDBUT
			toggle bubbALOptOnToggle
		}
		label
		{
			name "bubbALOptOn"
			area -1 -1 102 32
			text "Autoloot On"
			text style 'normal'
			text align left center
		}

		-- Critical Items
		button
		{
			name "bubbALOptCriticalItemsToggle"
			area -1 -1 32 32
			bam ROUNDBUT
			toggle bubbALOptCriticalItemsToggle
		}
		label
		{
			name "bubbALOptCriticalItems"
			area -1 -1 102 32
			text "Critical Items"
			text style 'normal'
			text align left center
		}

		-- Enchanted Weapons
		button
		{
			name "bubbALOptEnchantedWeaponsToggle"
			area -1 -1 32 32
			bam ROUNDBUT
			toggle bubbALOptEnchantedWeaponsToggle
		}
		label
		{
			name "bubbALOptEnchantedWeapons"
			area -1 -1 356 32
			text "Enchanted Weapons equal to or higher than enchantment level:"
			text style 'normal'
			text align left center
		}
		edit
		{
			name "bubbALOptEnchantedWeaponsField"
			area -1 -1 20 32
			var bubbALOptEnchantedWeaponsField
			text style "edit"
			align left center
			maxlines 1
			action
			"
				if((tonumber(letter_pressed) ~= nil
					and #tostring(bubbALOptEnchantedWeaponsField) < 1)
					or not letter_pressed)
				then
					return 1
				else
					return 0
				end
			"
		}

		-- Gold
		button
		{
			name "bubbALOptGoldToggle"
			area -1 -1 32 32
			bam ROUNDBUT
			toggle bubbALOptGoldToggle
		}
		label
		{
			name "bubbALOptGold"
			area -1 -1 356 32
			text "Gold"
			text style 'normal'
			text align left center
		}

		-- Price
		button
		{
			name "bubbALOptPriceToggle"
			area -1 -1 32 32
			bam ROUNDBUT
			toggle bubbALOptPriceToggle
		}
		label
		{
			name "bubbALOptPrice"
			area -1 -1 218 32
			text "Price equal to or higher than:"
			text style 'normal'
			text align left center
		}
		edit
		{
			name "bubbALOptPriceField"
			area -1 -1 50 32
			var bubbALOptPriceField
			text style "edit"
			align left center
			maxlines 1
			action
			"
				if((tonumber(letter_pressed) ~= nil
					and #tostring(bubbALOptPriceField) < 5)
					or not letter_pressed)
				then
					return 1
				else
					return 0
				end
			"
		}

		-- Price per Weight
		button
		{
			name "bubbALOptPricePerWeightToggle"
			area -1 -1 32 32
			bam ROUNDBUT
			toggle bubbALOptPricePerWeightToggle
		}
		label
		{
			name "bubbALOptPricePerWeight"
			area -1 -1 308 32
			text "Price per Weight equal to or higher than:"
			text style 'normal'
			text align left center
		}
		edit
		{
			name "bubbALOptPricePerWeightField"
			area -1 -1 50 32
			var bubbALOptPricePerWeightField
			text style "edit"
			align left center
			maxlines 1
			action
			"
				if((tonumber(letter_pressed) ~= nil
					and #tostring(bubbALOptPricePerWeightField) < 5)
					or not letter_pressed)
				then
					return 1
				else
					return 0
				end
			"
		}
	}

	-- BUBB EDIT LOOT END
%






